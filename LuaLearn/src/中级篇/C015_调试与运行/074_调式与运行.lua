---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by admin.
--- DateTime: 2021/5/8 9:50
---
--[[
执行外部代码
    方法1：loadfile 编译外部代码块，但不会运行代码，将会以函数的形式返回编译结果。
        注意：这里因为仅返回编译后的结果函数，所以在调用外部lua文件函数之前，必须先调用本结果函数。
    方法2：dofile 直接运行外部代码块，并不返回任何结果。dofile是loadfile的进一步简化封装。
    方法3: loadstring 编译字符串中的代码，而非从文件中读取。
          注意事项1：loadstring因编译时不涉及词法域（即：闭包）因此与function定义的函数不等价。
          loadstring总是在全局环境中编译它的字符串。
          注意事项2：loadstring在编译时不涉及词法域，所以loadstring在编译时不会显示错误信息，只有当使用assert时才
          可以显示loadstring中的错误。
    dofile与loadfile区别：
        dofile 编译并运行代码块，而loadfile只编译不运行。
        dofile 不返回任何结果，loadfile返回编译结果函数。
        dofile 是loadfile的封装，loadfile是dofile的核心。
        dofile 如果编译失败将会引发一个错误，loadfile不会引发错误而会返回nil及错误信息。
    dofile与loadfile的优缺点分析：
        对于简单任务dofile非常的便捷，在一次调用中完成整个编译与运行。

        而loadfile更加的灵活，在发生错误的情况下loadfile会返回nil以及错误信息，这可以按自定义的方式去处理错误。

        当需要多次运行一个文件时，只需要调用一次loadfile并保存编译结果函数，然后多次调用编译结果函数即可，优点是
        只编译一次可多次运用。而dofile每次运行都需要从新编译，相较dofile而言loadfile的开销将小很多。
lua错误与异常处理
    Lua所遇到的任何未预期条件都会发一个错误。因此在发生错误时不能简单的崩溃或退出，而是结束当前程序块并返回应用程序。当错误
    引发时进行恰当的处理是最合适的。
    lua语言主要使用error()/assert() 函数来抛出错误，使用pcall()/xpcall() 来捕获错误。

    assert()函数是error的进一步封装，简化处理
    assert()函数定义：
        assert首先检查第一个参数是否返回错误，如果不返回错误，则assert简单返回，否则则以第二个参数抛出异常信息。
        assert(a,b)参数a是要检查是否有错误的一个参数，b是a错误时抛出的信息。第二个参数b是可选的。

    pcall()捕获错误/lua错误 解释：pcall函数可以捕获函数执行中的任何错误，如果没有发生错误，那么返回
        true及函数调用的返回值，否则返回false及错误信息。当然错误信息不一定是一个字符串，还可以是lua中的任何值。
    xpcall()捕获错误
        pcall()函数的优点”简单“，但是缺点是不能输出错误堆栈信息。
        如果希望我们捕获错误信息，且显示完整的堆栈错误信息，则需要使用xpcall函数。
        xpcall()函数必须输入两个函数，前者是可能引发错误的函数，后者是错误处理函数。
lua垃圾收集机制
    Lua语言使用collectgarbage()函数来做垃圾回收机制
]]

